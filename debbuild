#!/usr/bin/perl -w
# debbuild script
# Shamelessly steals interface from rpm's "rpmbuild" to create
# Debian packages.  Please note that such packages are highly
# unlikely to conform to "Debian Policy".
###
# SVN revision info
# $Date$
# SVN revision $Rev$
# Last update by $Author$
###
# Copyright (C) 2005-2015 Kris Deugau <kdeugau@deepnet.cx>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

use strict;
use warnings;

use Cwd 'abs_path';	# for finding where files really are
use Fcntl;		# for sysopen flags
use File::Basename;
use Getopt::Long qw(:config no_ignore_case bundling);

my $version = "0.15.11";	#VERSION#

# regex debugger
#use re "debug";

# Behavioural compatibility FTW!  Yes, rpmbuild does this too.
die "No .spec file to work with!  Exiting.\n" unless @ARGV;

# Program flow:
# -> Parse/execute "system" config/macros (if any - should be rare)
# -> Parse/execute "user" config/macros (if any - *my* requirement is %_topdir)
# -> Parse command line for options, spec file/tarball/.src.deb (NB - also accept .src.rpm)

# Initialized globals
my $verbosity = 0;
my $NoAutoReq = 0;
my %cmdopts = (type => '',
		stage => 'a',
		short => 'n');
my %defattr = (filemode => '-',
		owner => '-',
		group => '-',
		dirmode => '-');
my @ifexpr = (); # Nested %if..%else..%endif conditionals

# User's prefs for dirs, environment, etc,etc,etc.
# config file ~/.debmacros
# Default ordered search paths for config/macros:
# /usr/lib/rpm/rpmrc  /usr/lib/rpm/redhat/rpmrc  /etc/rpmrc      ~/.rpmrc
# /usr/lib/rpm/macros /usr/lib/rpm/redhat/macros /etc/rpm/macros ~/.rpmmacros
# **NOTE:  May be possible to (ab)use bits of debhelper
my %specglobals = ( # For %define's in specfile, among other things.
	# this can be changed by the Vendor: header in the spec file
	vendor => 'debbuild');

# "Constants"
my %targets = ('p' => 'Prep',
		'c' => 'Compile',
		'i' => 'Install',
		'l' => 'Verify %files',
		'a' => 'Build binary and source',
		'b' => 'Build binary',
		's' => 'Build source');
# Ah, the joys of multiple architectures.  :(  Feh.
# As copied from rpm
my %optflags = ( 'i386' => '-O2 -g -march=i386 -mcpu=i686',
		'amd64'	=> '-O2 -g',
		  'all'	=> '');

# Hackery to try to bring some semblance of sanity to packages built for more
# than one Debian version at the same time.  Whee.
# /etc/debian-version and/or version of base-files package
my %distmap = (
# legacy Unbuntu
	"3.1.9ubuntu"	=> "dapper",
	"6.06"		=> "dapper",
	"4ubuntu"	=> "feisty",
	"7.04"		=> "feisty",
        "4.0.1ubuntu"	=> "hardy",
	"8.04"		=> "hardy",
# Note we do NOT support identification of "subrelease" versions (ie semimajor updates
# to a given release).  If your dependencies are really that tight, and you can't rely
# on the versions of the actual dependencies, you're already in over your head, and
# should probably only ship a tarballed installer.
# only supporting LTS releases
# base-files version doesn't map to the Ubuntu version the way Debian versions do, thus the doubled entries
#	Ubuntu 12.04.5 LTS (Precise Pangolin)
	"6.5ubuntu"	=> "precise",
	"12.04"		=> "precise",
#	Ubuntu 14.04.2 LTS (Trusty Tahr)
	"7.2ubuntu"	=> "trusty",
	"14.04"		=> "trusty",
# Debian releases
	"3.0"	=> "woody",
	"3.1"	=> "sarge",
	"4"	=> "etch",
	"5"	=> "lenny",
	"6"	=> "squeeze",
	"7"	=> "wheezy",
	"8"	=> "jessie",
	"9"	=> "stretch",
	"99"	=> "sid");

# Map Ubuntu base-files versions to the nominal public versions
my %ubnt_vermap = ("6.5ubuntu6" => "12.04",
		   "7.2ubuntu5" => "14.04");

# Enh.  There doesn't seem to be any better way to do this...  :(
{
# could theoretically also do something with this...  it's about as stable as "dpkg-query ..." below...  :(
#  my $releasever = qx { cat /etc/debian_version };
#  chomp $releasever;
  my $basefiles;
  my $basever;
  my $baseos;

  # Funny thing how files like this have become useful...
  # Check for /etc/os-release.  If that doesn't exist, try /etc/lsb-release.  If that doesn't exist,
  # check for existence of dpkg-query, and either call it Debian Woody (if missing), or fall through
  # to guessing based on the version of the base-files package.
  if (-e '/etc/os-release') {
    open OSREL, "</etc/os-release";
    # Look for ID and VERSION_ID lines.
    while (<OSREL>) {
      $baseos = $1 if /^ID=(\w+)/;
      $basever = $1 if /^VERSION_ID="?([\d.]+)/; # " closed
    }
    close OSREL;

  } elsif (-e '/etc/lsb-release') {
    open LSBREL, "</etc/lsb-release";
    # Look for DISTRIB_ID and DISTRIB_RELEASE lines.
    # We could also theoretically extract the dist codename, but since we have to hand-map
    # it in so many other cases there's little point.
    while (<LSBREL>) {
      $baseos = $1 if /^DISTRIB_ID=(\w+)/;
      $basever = $1 if /^DISTRIB_RELEASE=([\d.]+)/;
    }
    close LSBREL;

  } elsif (not -e '/usr/bin/dpkg-query' ) {
    # call it woody, since sarge and newer have dpkg-query, and we don't much care about obsolete^n releases
    $basever = "3.0";
    $baseos = 'debian';

  } else {
# *eyeroll*  there *really* has to be a better way to go about this.  You
# can't sanely build packages for multiple distro targets if you can't
# programmatically figure out which one you're building on.

# note that we care only about major release numbers; tracking minor or point
# releases would be...  exponentially more painful.

    my $majver;
    # for the lazy copy-paster:  dpkg-query --showformat '${version}\n' -W base-files
    # avoid shellisms
    if (open BASEGETTER, "-|", "dpkg-query", "--showformat", '${version}', "-W", "base-files") {
      $basever = <BASEGETTER>;
      close BASEGETTER;

      if ($basever =~ /ubuntu/) {
        # Ubuntu, at least until they upset their versioning scheme again
        # note that we remap the basefiles version to the public release number, to match the
        # behaviour for Debian, and to match the unofficial standard for RHEL/Centos etc and Fedora
        ($basefiles,$basever) = ($basever =~ /^(([\d.]+)ubuntu)\d/);
        $baseos = 'ubuntu';
      } else {
        # Debian, or more "pure" derivative
        $baseos = 'debian';
        ($basever,$majver) = ($basever =~ /^((\d+)(?:\.\d)?)/);
        $basever = $majver if $majver > 3;
      }
    }

    if (not $basever) {
      # Your llama is on fire
      $basever = '99';
      print "Warning:  couldn't autodetect OS version, assuming sid/unstable\n";
    }
  } # got dpkg-query?

  # Set some legacy globals.
  $specglobals{debdist} = $distmap{$basever};
  $specglobals{debver} = $basever;   # this may have trouble with Ubuntu versions?

  # Set the standard generic OS-class globals;
  $baseos = lc($baseos);
  $specglobals{ubuntu} = $basever if $baseos eq 'ubuntu';
  $specglobals{debian} = $basever if $baseos eq 'debian';

  # Default %{dist} to something marginally sane.  Note this should be overrideable by --define.
  # This has been chosen to most closely follow the usage in RHEL/CentOS and Fedora, ie "el5" or "fc20".
  $specglobals{dist} = $baseos.$basever;

} # done trying to set debian dist/version

# Package data
# This is the form of $pkgdata{pkgname}{meta}
# meta includes Summary, Name, Version, Release, Group, Copyright,
#	Source, URL, Packager, BuildRoot, Description, BuildRequires,
#	Requires, Provides
# 10/31/2005 Maybe this should be flatter?  -kgd
my %pkgdata = (main => {source => ''});
my @pkglist = ('main');	#sigh
# Files listing.  Embedding this in %pkgdata would be, um, messy.
my %filelist;
my %doclist;
my $buildreq = '';

# Scriptlets
my $scriptletbase = q(%{___build_template});
my ($prepscript, $buildscript, $installscript) = ('') x 3;
my $cleanscript = '[ "$RPM_BUILD_ROOT" != "/" ] && %{__rm} -rf $RPM_BUILD_ROOT';
my $finalmessages = ''; # A place to stuff messages that I want printed at the *very* end of any processing.

##main

load_config();
parse_cmd();

# global shortcuts
my $topdir = expandmacros($specglobals{_topdir});
my $tmpdir = expandmacros($specglobals{_tmppath});

if ($cmdopts{type} eq 's') {
  install_sdeb($specglobals{srcpkg});
  exit 0;
}

# output stage of --showpkgs
if ($cmdopts{type} eq 'd') {
  parse_spec($specglobals{specfile});
  foreach my $pkg (@pkglist) {
    $pkgdata{$pkg}{name} =~ tr/_/-/;

    my $pkgfullname = "$pkgdata{$pkg}{name}_".
	(defined($pkgdata{main}{epoch}) ? "$pkgdata{main}{epoch}:" : '').
	"$pkgdata{$pkg}{version}-$pkgdata{main}{release}_$pkgdata{$pkg}{arch}.deb";

    print "$pkgfullname\n" if $filelist{$pkg};

  }
  # Source package
  print "$pkgdata{main}{name}-".
	(defined($pkgdata{main}{epoch}) ? "$pkgdata{main}{epoch}:" : '').
	"$pkgdata{main}{version}-$pkgdata{main}{release}.sdeb\n";
  exit 0;
}

# Stick --rebuild handling in here - basically install_sdeb()
# followed by tweaking options to run with -ba
# --recompile is the same, except it reconfigures -bi
if ($cmdopts{type} eq 'r') {
  my $specfile;
  if ($specglobals{srcpkg} =~ /\.src\.rpm$/) {
    my @srclist = grep { /\.spec/ } qx ( rpm -qlp $specglobals{srcpkg} );
    chomp( $specfile = $srclist[0] );
    qx ( rpm -i $specglobals{srcpkg} );
  } elsif ($specglobals{srcpkg} =~ /\.sdeb$/) {
    install_sdeb($specglobals{srcpkg});
    chomp( $specfile = basename( qx ( pax -f $specglobals{srcpkg} *.spec ) ) );
  } else {
    die "Can't --rebuild with $specglobals{srcpkg}\n";
  }
  $specglobals{specfile} = "$topdir/SPECS/$specfile";
  $cmdopts{type} = 'b'; # fall through
}

if ($cmdopts{type} eq 't') {
  # Need to inspect the tarball to find the spec file.
  # Note that rpmbuild doesn't seem to support this operation from a
  # .zip file properly, but we try our best.
  my $cmdline;
  die "No tarfile specified!  Exiting.\n" unless defined $specglobals{tarball};
  my $tarball = $specglobals{tarball};
  if ($tarball =~ /\.zip$/) {
    # .zip files are not really tarballs
    $cmdline = "%{__unzip} -Z1 %{tarball} '*.spec'";
  } elsif ($tarball =~ /\.tar$/) {
    # plain .tar files don't need to be uncompressed
    $cmdline = "%{__tar} -tf %{tarball} --wildcards '*.spec'";
  } else {
    $cmdline = decompress($tarball)." | %{__tar} -tf - --wildcards '*.spec'";
  }
  $cmdline = expandmacros($cmdline);
  chomp( $specglobals{specfile} = "$topdir/SPECS/".basename( qx { $cmdline } ) );

  $tarball = abs_path($tarball);

  if ($tarball =~ /\.zip$/) {
    # .zip files are not really tarballs
    $cmdline = "%{__unzip} -p %{tarball} '*.spec'";
  } elsif ($tarball =~ /\.tar$/) {
    # plain .tar files don't need to be uncompressed
    $cmdline = "%{__tar} -xOf %{tarball} --wildcards '*.spec'";
  } else {
    $cmdline = decompress($tarball)." | %{__tar} -xOf - --wildcards '*.spec'";
  }
  $cmdline .= " > %{specfile}\n%{__cp} -f %{tarball} %{_sourcedir}";
  system expandmacros($cmdline);

  $cmdopts{type} = 'b'; # fall through
}

if ($cmdopts{type} eq 'b') {
  # Need to read the spec file to find the tarball.  Note that
  # this also generates most of the shell script required.
  parse_spec($specglobals{specfile});
  die "Can't build $pkgdata{main}{name}:  build requirements not met.\n"
    unless checkbuildreq();
}

# Hokay.  Need to:
# -> prep if -.p OR (-.[cilabs] AND !--short-circuit)
if ($cmdopts{stage} eq 'p' || ($cmdopts{stage} =~ /[cilab]/ && $cmdopts{short} ne 'y')) {
  prep();
}
# -> build if -.c OR (-.[ilabs] AND !--short-circuit)
if ($cmdopts{stage} eq 'c' || ($cmdopts{stage} =~ /[ilab]/ && $cmdopts{short} ne 'y')) {
  build();
}
# -> install if -.[ilabs]
#if ($cmdopts{stage} eq 'i' || ($cmdopts{stage} =~ /[lab]/ && $cmdopts{short} ne 'y')) {
if ($cmdopts{stage} =~ /[ilab]/) {
  install();
}
# -> binpkg and srcpkg if -.a
if ($cmdopts{stage} eq 'a') {
  binpackage();
  srcpackage();
  clean();
}
# -> binpkg if -.b
if ($cmdopts{stage} eq 'b') {
  binpackage();
  clean();
}
# -> srcpkg if -.s
if ($cmdopts{stage} eq 's') {
  srcpackage();
}

# Spit out any closing remarks
print $finalmessages;

# Just in case.
exit 0;


## load_config()
# Load system macros similar to RPM which digests
# /usr/lib/rpm/macros /usr/lib/rpm/redhat/macros /etc/rpm/macros
# and user configuration (if any) ~/.rpmmacros a.k.a. ~/.debmacros
sub load_config {
  # Load user configuration, permitting local override
  my $homedir = (getpwuid($<))[7];
  foreach my $macros ( ('/usr/lib/debbuild/macros',
                        '/etc/debbuild/macros',
                        "$homedir/.debmacros") ) {
    next unless -e $macros; # should we warn about missing macro files?
    open MACROS,"<$macros";
    while (<MACROS>) {
      next unless (my ($macro,$value) = (/^%([a-z0-9_]+)\s+(.+)$/));
      if ($value =~ /\\$/) {
        while (<MACROS>) {
          $specglobals{$macro} .= $_;
          last unless /\\$/;
        }
      } else {
        $specglobals{$macro} = $value;
      }
    }
    close MACROS;
  }
} # end load_config()


## parse_cmd()
# Parses command line into global hash %cmdopts, other globals
# Options based on rpmbuild's options
sub parse_cmd {
  # Don't feel like coding my own option parser...
  Getopt::Long::GetOptions(
    'buildroot=s'   => \$specglobals{buildroot},
    'short-circuit' => sub { $cmdopts{short} = 'y' },
    'showpkgs'      => sub { $cmdopts{type} = 'd' },
    'define|D=s' => sub {
        my ($opt_name,$opt_value) = @_;
        my ($macro,$value) = ($opt_value =~ m/([a-z0-9_.-]+)(?:\s+(.+))?/i);
        if ($value) {
          if ($macro =~ /(?:summary|name|epoch|version|release|group|copyright|url|packager)/i) {
            $pkgdata{main}{$macro} = $value;
          } else {
            $specglobals{$macro} = $value;
          }
        } else {
          warn "WARNING: missing value for macro $macro in --$opt_name! Ignoring.\n";
        }
      },
    'v+' => \$verbosity, # bump verbosity.  Not sure what I'll actually do here...
    'rebuild=s'   => \&srcpkg_handler,
    'recompile=s' => \&srcpkg_handler,
    'install|i=s' => \&srcpkg_handler,
    'b=s'         => \&build_handler, # do NOT use 'b|t=s' here!
    't=s'         => \&build_handler, # see 'build_handler' for details
    'r=s'         => \&build_handler,
    'with=s'      => \&with_handler, # dito for 'with|without=s'
    'without=s'   => \&with_handler,
    'help'        => \&help_handler,
    '<>'          => \&catchall # process non-option arguments
  ); # Getopt::Long::Getoptions()
  ## catchall()
  # --buildroot, --define|-D, --rebuild, --recompile, and --install|-i are the
  # only options that take an argument.  Therefore, any *other* bare arguments
  # are the spec file or the tarball we're operating on - depending on which
  # one we meet.
  sub catchall {
    my ($opt_arg) = @_;
    if ($cmdopts{type} eq 'b' || $cmdopts{type} eq 'd') {
      # Spec file
      $specglobals{specfile} = $opt_arg;
    } elsif ($cmdopts{type} eq 't') {
      # Tarball build.  Need to extract tarball to find spec file.  Whee.
      $specglobals{tarball} = $opt_arg;
    } else {
      # Source package
      $specglobals{srcpkg} = $opt_arg;
    }
  }
  ## srcpkg_handler()
  # prepare $specglobals{srcpkg} in dependence of the calling option
  sub srcpkg_handler {
    my ($opt_name,$opt_value) = @_;
    $specglobals{srcpkg} = $opt_value;
    $cmdopts{type} = 's'; # --install
    if ($opt_name eq 'rebuild') {
      $cmdopts{type} = 'r';
      $cmdopts{stage} = 'a';
    } elsif ($opt_name eq 'recompile') {
      $cmdopts{type} = 'r';
      $cmdopts{stage} = 'i';
    }
  }
  ## build_handler()
  # You can't use 'b|t=s' in Getopt::Long::GetOptions(), because 't' will be
  # treated as an 'alias' to the 'primary' option 'b' and will NOT receive its
  # own $opt_name.  We have to factor-out the handler and use _two_ options.
  sub build_handler {
    my ($opt_name,$opt_value) = @_;
    if ($cmdopts{type} eq 'r') {
      # Mutually exclusive options.
      die "Can't use -$opt_name$opt_value with --rebuild\n";
    } else {
      $cmdopts{type} = $opt_name;
      $cmdopts{stage} = $opt_value;
    }
  }
  ## with_handler()
  # create 'configure' options from '--with <flag>' and '--without <flag>':
  # rpmbuild literally defines these options as 'aliases' for
  # --define="_with_<flag> --with-<flag>" and
  # --define="_without_<flag> --without-<flag>" resp.
  sub with_handler {
    my ($opt_name,$opt_value) = @_;
    $specglobals{"\_$opt_name\_$opt_value"} = "--$opt_name-$opt_value";
  }
  ## help_handler()
  # Factor-out the 'help' text. Could as well be SYNOPSIS in pod.
  sub help_handler {
    print "debbuild v$version".q{
Copyright 2005-2015 Kris Deugau <kdeugau@deepnet.cx>

Build .deb packages from RPM-style .spec files
debbuild supports most package-building options rpmbuild does.

Build options with [ <specfile> | <tarball> | <source package> ]:
      -bp                        build through %prep (unpack sources and apply patches) from <specfile>
      -bc                        build through %build (%prep, then compile) from <specfile>
      -bi                        build through %install (%prep, %build, then install) from <specfile>
      -bl                        verify %files section from <specfile>
      -ba                        build source and binary packages from <specfile>
      -bb                        build binary package only from <specfile>
      -bs                        build source package only from <specfile>
      -tp                        build through %prep (unpack sources and apply patches) from <tarball>
      -tc                        build through %build (%prep, then compile) from <tarball>
      -ti                        build through %install (%prep, %build, then install) from <tarball>
      -ta                        build source and binary packages from <tarball>
      -tb                        build binary package only from <tarball>
      -ts                        build source package only from <tarball>
      -rp                        build through %prep (unpack sources and apply patches) from <source package>
      -rc                        build through %build (%prep, then compile) from <source package>
      -ri                        build through %install (%prep, %build, then install) from <source package>
      -ra                        build source and binary packages from <source package>
      -rb                        build binary package only from <source package>
      -rs                        build source package only from <source package>
      --rebuild (-rb)            build binary package from <source package>
      --recompile (-ri)          build through %install from <source package>
      --buildroot=DIRECTORY      override build root
      --short-circuit            skip straight to specified stage (only for c,i)

Common options:
  -D, --define='MACRO EXPR'      define MACRO with value EXPR

debbuild-specific options:
      -i, --install              Unpack a .sdeb in the %_topdir tree
      --showpkgs                 Show package names that would be built.  Only works with .spec files.
};
    exit;
  }

  # Some cross-checks.  rpmbuild limits --short-circuit to just
  # the "compile" and "install" targets - with good reason IMO.
  # Note that --short-circuit with -.p is not really an error, just redundant.
  # NB - this is NOT fatal, just ignored!
  if ($cmdopts{short} eq 'y' && $cmdopts{stage} =~ /[labs]/) {
    warn "Can't use --short-circuit for $targets{$cmdopts{stage}} stage.  Ignoring.\n";
    $cmdopts{short} = 'n';
  }

  # Did we catch an action option?
  # rpmbuild quits silently.
  exit 0 unless $cmdopts{type};

} # end parse_cmd()


## parse_spec()
# Parse the .spec file.
sub parse_spec {
  my ($specfile) = @_;
  die "No .spec file specified!  Exiting.\n" unless $specfile;
  open SPECFILE,"<$specfile" or die "specfile ($specfile) barfed: $!";

  my $buildarch = expandmacros("%{_arch}");
  $pkgdata{main}{arch} = $buildarch;

  my $stage = 'preamble';
  my $subname = 'main';
  my $scriptlet;

# Basic algorithm:
# For each line
#   if it's a member of an %if construct, branch and see which segment of the
#	spec file we need to parse and which one gets discarded, then
#	short-circuit back to the top of the loop.
#   if it's a %section, bump the stage.  Preparse addons to the %section line
#	(eg subpackage) and stuff them in suitable loop-global variables, then
#	short-circuit back to the top of the loop.
#   Otherwise, parse the line according to which section we're supposedly
#	parsing right now

LINE: while (<SPECFILE>) {
    next if /^#/;       # Ignore comments...
    next if /^\s*$/;    # ... and blank lines.

# no sense in continuing if we find something we don't grok
    # Yes, this is really horribly fugly.  But it's a cheap crosscheck against invalid
    # %-tags which also make rpmbuild barf.  In theory.
# notes:  some of these are not *entirely* case-sensitive (%ifxxx), but most are.
    # Extracted from the Maximum RPM online doc via:
    # grep -h %[a-z] *|perl -e 'while (<>) { /\%([a-z0-9]+)\b/; print "$1|\n"; }'|sort -u
    if (/^%[a-z]/ &&
		$_ !~ /^%(?:attr|build|changelog|check|clean|config|configure|
		defattr|define|description|dir|doc|docdir|else|endif|files|ghost|
		if|ifarch|ifnarch|ifnos|ifos|install|make_install|makeinstall|
		package|patch\d*|post|postun|pre|prep|preun|readme|setup\d*|
		triggerin|triggerpostun|triggerun|verify|verifyscript)\b/x
	) {
	my ($badtag) = (/^%([a-z]+)/i);
	die "Unknown tag \%$badtag at line $. of $specfile\n";
    }

# preprocess %define's
    if (my ($key, $def) = (/^\%(?:define|global)\s+([^\s]+)\s+(.+)$/) ) {
      if ($key =~ /(?:summary|name|epoch|version|release|group|copyright|url|packager)/i) {
        $pkgdata{main}{$key} = expandmacros($def) unless defined $pkgdata{main}{$key};
      } else {
        $specglobals{$key} = expandmacros($def) unless defined $specglobals{$key};
      }
    }

    # RPM conditionals – transform to generic form
    s/^%ifos/%if %{_os}==/;
    s/^%ifnos/%if %{_os}!=/;
    s/^%ifarch/%if %{_arch}==/;
    s/^%ifnarch/%if %{_arch}!=/;

    # Generic %if..%else..%endif construct
    if (s/^%if//) {
      chomp;
      my $expr = lc expandmacros($_);

      if ($expr !~ /^[\d\s<=>&|\-+\(\)]+$/) {
        # got a logic statement we want to turn into a 1 or a 0.
        # most likely by eval'ing it.

        $expr =~ s/\s//g;

# For Great w00tness!  New and Improved multilayered logic handling.

	my @bits = split /\b/, $expr;
	$expr = '';
	foreach my $bit (@bits) {
	  next if $bit eq '"';
	  $bit =~ s/"//g;
	  $expr .= ( $bit =~ /^\w+$/ ? qq("$bit") : $bit );
	}

        # Done in this order so we don't cascade incorrectly.  Yes, those spaces ARE correct in the replacements!
        $expr =~ s/==/ eq /g;
        $expr =~ s/!=/ ne /g;
        $expr =~ s/<=>/ cmp /g;
        $expr =~ s/<=/ le /g;
        $expr =~ s/>=/ ge /g;
        $expr =~ s/</ lt /g;
        $expr =~ s/>/ gt /g;

      } else {
        # "plain" numeric expressions are evaluated as-is
        $expr =~ s/(\d+)/0$1/g; # in octal; e.g., 0%{?ubuntu}
      }

      # Turn it into something that evals to a number.  Maybe not needed?  O_o
      unshift @ifexpr, (eval $expr || 0);

      next LINE if $ifexpr[0] != 0; # This appears to be the only case we call false.
      my $iflevel = @ifexpr;
      while (<SPECFILE>) { # Skip %if-block, inluding nested %if..%else..%endif
        if (/^%if/) {
          $iflevel++;
        } elsif (/^%else/) {
          goto ELSE if $iflevel == @ifexpr;
        } elsif (/^%endif/) {
          goto ENDIF if $iflevel == @ifexpr;
          $iflevel--;
        }
      }
    }
ELSE: if (/^%else/) {
      next LINE if $ifexpr[0] == 0;
      my $iflevel = @ifexpr;
      while (<SPECFILE>) { # Skip %else-block, inluding nested %if..%else..%endif
        if (/^%if/) {
          $iflevel++;
        } elsif (/^%else/) {
          goto ELSE if $iflevel == @ifexpr;
        } elsif (/^%endif/) {
          goto ENDIF if $iflevel == @ifexpr;
          $iflevel--;
        }
      }
    }
ENDIF: if (/^%endif/) {
      shift @ifexpr;
      next LINE;
    } # %if..%else..%endif

    if (/^\%{echo:(.+)}/) {
      print expandmacros($1),"\n";
      next LINE;
    }

# now we pick out the sections and set "state" to parse that section.  Fugly but I can't see a better way.  >:(

    if (/^\%description(?:\s+(?:-n\s+)?(.+))?/) {
      $stage = 'desc';
      $subname = "main";
      if ($1) {       # Magic to add entries to the right package
        my $tmp = expandmacros("$1");
        $subname = /-n/ ? $tmp : "$pkgdata{main}{name}-$tmp";
      }
      next LINE;
    } # %description

    if (/^\%package\s+(?:-n\s+)?(.+)/) {
      $stage = 'package';
      if ($1) {       # Magic to add entries to the right package
        my $tmp = expandmacros("$1");
        $subname = /-n/ ? $tmp : "$pkgdata{main}{name}-$tmp";
      }
      push @pkglist, $subname;
      $pkgdata{$subname}{name} = $subname;
      $pkgdata{$subname}{version} = $pkgdata{main}{version};
  # Build "same arch as previous package found" by default.  Where rpm just picks the
  # *very* last one, we want to allow arch<native>+arch-all
  # (eg, Apache is i386, but apache-manual is all)
      $pkgdata{$subname}{arch} = $buildarch;  # Since it's likely subpackages will NOT have a BuildArch line...
      next LINE;
    } # %package

    if (/^\%prep/) {
      $stage = 'prep';
      # Replace some core macros
      $pkgdata{main}{source} = expandmacros($pkgdata{main}{source});
      next LINE;
    } # %prep

    if (/^\%build/) {
      $stage = 'build';
      $buildscript .= "cd '%{buildsubdir}'\n" if $pkgdata{main}{hassetup};
      next LINE;
    } # %build

    if (/^\%install/) {
      $stage = 'install';
      $installscript .= "cd '%{buildsubdir}'\n" if $pkgdata{main}{hassetup};
      next LINE;
    } # %install

    if (/^\%clean/) {
      $stage = 'clean';
      $cleanscript .= "cd '%{buildsubdir}'\n" if $pkgdata{main}{hassetup};
      next LINE;
    } # %clean

    if (/^\%(pre|post|preun|postun)\b(?:\s+(?:-n\s+)?(.+))?/i) {
      $stage = 'prepost';
      $scriptlet = lc $1;
      $subname = 'main';
      if ($2) {       # Magic to add entries to the right package
        my $tmp = expandmacros("$2");
        $subname = /-n/ ? $tmp : "$pkgdata{main}{name}-$tmp";
      }
      next LINE;
    } # %pre/%post/%preun/%postun

    if (/^\%files(?:\s+(?:-n\s+)?(.+))?/) {
      $stage = 'files';
      $subname = 'main';
      if ($1) {       # Magic to add entries to the right list of files
        my $tmp = expandmacros("$1");
        $subname = /-n/ ? $tmp : "$pkgdata{main}{name}-$tmp";
      }
      next LINE;
    } # %files

    if (/^\%changelog/) {
      $stage = 'changelog';
      $pkgdata{main}{changelog} = '';
      next LINE;
    }

# now we handle individual lines from the various sections

    if ($stage eq 'desc') {
      next LINE if /^\s*#/;
      $pkgdata{$subname}{desc} .= " $_";
    } # description

    if ($stage eq 'package') {
      # gotta expand %defines here.  Whee.
# Note that we look for the Debian-specific Recommends, Suggests, and Replaces,
# although they will have to be wrapped in '%if %{_vendor} == "debbuild"' for
# an rpmbuild-compatible .spec file
# NB: NOT going to support Pre-Depends, since it's a "Don't Use" (mis)feature, and
# RPM's support for a similar tag (PreReq) has been recently dropped.
      if (my ($dname,$dvalue) = (/^(Recommends|Suggests|Enhances|Replaces|Summary|Group|Version|Requires|Conflicts|Provides|BuildArch(?:itecture)?):\s+(.+)$/i)) {
        $dname =~ tr/[A-Z]/[a-z]/;
        if ($dname =~ /^BuildArch/i) {
          $dvalue =~ s/^noarch/all/ig;
          $buildarch = $dvalue;     # Emulate rpm's behaviour to a degree
          $dname = 'arch';
        }
        if ($dname =~ /recommends|suggests|enhances|replaces|requires|conflicts|provides/) {
          $pkgdata{$subname}{$dname} .= ", ".expandmacros($dvalue);
        } else {
          $pkgdata{$subname}{$dname} = expandmacros($dvalue);
        }
      }
    } # package

    if ($stage eq 'prep') {
      # Actual handling for %prep section.  May have %setup macro;  may
      # include %patch tags, may be just a bare shell script.
      if (s/^\%setup//) {
        $pkgdata{main}{hassetup} = 1;  # flag the fact that we've got %setup
        # Parse out the %setup macro.  rpmbuild doesn't complain about
        # gibberish immediately following %setup, but we will
        if (not /^(?:\s|$)/) {
          chomp;
          warn "Suspect \%setup tag '\%setup$_', continuing\n";
          s/^[^\s]+//;
        }

        # Prepare some flags
        my ($createdir, $leavedirs, $quietunpack, $skipdefault) = (0) x 4;
        my (@sbefore, @safter);

        Getopt::Long::GetOptionsFromString($_,
          'n=s' => \$specglobals{buildsubdir},
          'c'   => \$createdir,   # flag, create and change directory before unpack
          'D'   => \$leavedirs,   # flag, do not delete directory before unpack
          'T'   => \$skipdefault, # flag, do not unpack first source
          'q'   => \$quietunpack, # SSH!  Unpack quietly
          'b=i' => \@sbefore,
          'a=i' => \@safter);

# Note that this is an incomplete match to rpmbuild's full %setup expression.
# Known differences
# - -q appears to be somewhat positional in rpm
# - rpmbuild requires -n on all %setup macros, but carries the first down to
#   %install etc, debbuild sets the global on the first call, and keeps using
#   it for further %setup calls

        $prepscript .= "cd '%{_builddir}'\n";
        $prepscript .= "%{__rm} -rf '%{buildsubdir}'\n" unless $leavedirs;

        foreach (@sbefore) {
          $prepscript .= unpackcmd($pkgdata{sources}{$_},$quietunpack);
        }

        if ($createdir) {
          $prepscript .= "%{__mkdir_p} %{buildsubdir}\n";
          $prepscript .= "cd '%{buildsubdir}'\n";
        }
        elsif (not $skipdefault) {
          $prepscript .= unpackcmd($pkgdata{main}{source},$quietunpack);
        }

        if (not $createdir) {
          $prepscript .= "cd '%{buildsubdir}'\n";
        }
        elsif (not $skipdefault) {
          $prepscript .= unpackcmd($pkgdata{main}{source},$quietunpack);
        }

        foreach (@safter) {
          $prepscript .= unpackcmd($pkgdata{sources}{$_},$quietunpack);
        }

# rpm doesn't seem to do the chowns any more
#		qq([ `%{__id_u}` = '0' ] && %{__chown} -Rhf root .\n).
#		qq([ `%{__id_u}` = '0' ] && %{__chgrp} -Rhf root .\n).
        $prepscript .=
		qq(%{__chmod} -Rf a+rX,u+w,g-w,o-w .\n);

      } elsif (s/^\%patch//) {
        # Things rpmbuild Does
        # -> blindly follows Patch(.*):  ==>  %patch$1
        # %patch0 does not in fact equal %patch without -P
        # spaces optional between flag and argument
        # multiple -P options actually trigger multiple patch events.  >_<
        # can we emulate this?
        # yes we can!
        my @patchlist;

        # add patch{nn} to the list
        if (s/^(\d+)//) {
          push @patchlist, "$1";
        }
        # add the "null" patch to the list unless we've got a -P flag
        elsif (not /-P/) {
          push @patchlist, '';
        }

        # %patch options:
        my ($fuzz, $plev, $psuff, $noempty, $reverse, $altdir, $output)
          = ($specglobals{_default_patch_fuzz}, 0, '', '', '', '', '');

        Getopt::Long::GetOptionsFromString($_,
          'P=i'   => \@patchlist, # patch number(s)
          'p=i'   => \$plev,      # path strip.  Passed to patch as-is
          'F=i'   => \$fuzz,      # fuzz factor.  Passed to patch as-is
          'd=s'   => \$altdir,    # alternative directory.  Passed to patch as-is
          'o=s'   => \$output,    # redirect output.  Passed to patch as-is
          'E'     => \$noempty,   # remove empty files.  Passed to patch as-is
          'R'     => \$reverse,   # reverse patch.  Passed to patch as-is
          'b|z=s' => \$psuff,     # backup file postfix.
            # Literal, if e.g. "bkfile", backup files will be "filebkfile",
            # not "file.bkfile".  Passed as-is, with a minor flag adjustment
          '<>' => sub {
              push @patchlist, @_; # all other arguments are patch numbers
            }
        );

        my $patchopts = $specglobals{_default_patch_flags};
        $patchopts .= " --fuzz=$fuzz -p$plev";
        $patchopts .= " -b --suffix=$psuff" if $psuff;
        $patchopts .= " -d $altdir" if $altdir;
        $patchopts .= " -o $output" if $output;
        $patchopts .= " -E" if $noempty;
        $patchopts .= " -R" if $reverse;

        foreach my $pnum (@patchlist) {
          $prepscript .= qq(echo "Patch ).($pnum eq '' ? '' : "#$pnum ").qq(($pkgdata{main}{$pnum}):"\n);
          if ( $pkgdata{main}{$pnum} =~ /\.(?:Z|gz|bz2|xz)$/ ) {
            # Compressed patch.  You weirdo.
            $prepscript .= decompress("%{_sourcedir}/$pkgdata{main}{$pnum}");
          } elsif ( $pkgdata{main}{$pnum} =~ /\.zip$/ ) {
            # .zip'ed patch.  *backs away slowly*
            $prepscript .= "%{__unzip} -p %{_sourcedir}/$pkgdata{main}{$pnum}";
          } else {
            $prepscript .= "%{__cat} %{_sourcedir}/$pkgdata{main}{$pnum}";
          }
          $prepscript .= " | %{__patch} $patchopts\n\n";
        }

      } else {
        $prepscript .= $_;
      }
      next LINE;
    } # prep

    if ($stage eq 'build') {
      $buildscript .= $_;
      next LINE;
    } # build

    if ($stage eq 'install') {
      $installscript .= $_;
      next LINE;
    } # install

    if ($stage eq 'clean') {
      $cleanscript .= $_;
      next LINE;
    } # clean

    if ($stage eq 'prepost') {
      $pkgdata{$subname}{$scriptlet} .= $_;
      next LINE;
    } # prepost

    if ($stage eq 'files') {
      # need to deal with these someday
      next LINE if /^\%verify/;
      # dunno what to do with this; not sure if there's space in Debian's package structure for it.
      next LINE if /^\%ghost/;
#      my $singleton = 0;	# don't recall what this was for
      next LINE if /^\s*#/;
      next LINE if /^\s*$/;

      if (/^%defattr\s*\(\s*((?:-|\d+)),?\s*(\w+),?\s*(\w+),?\s*((?:-|\d+))\s*\)/) {
        ($defattr{filemode}, $defattr{owner}, $defattr{group}, $defattr{dirmode}) =
          ($1, $2, $3, $4);
        next LINE;
      }

# create and initialize flags
      my ($perms, $owner, $group, $conf, $filesline) =
        ($defattr{filemode}, $defattr{owner}, $defattr{group}, '-', $_);

      # Debian dpkg doesn't speak "%docdir".  Meh.
      $filesline =~ s/^%dir\s*//;
      $filesline =~ s/^%docdir\s*//;

      # strip and flag %attr constructs
      if ($filesline =~ /%attr\b/) {
	# Extract %attr...
	my ($args) = (/(\%attr\s*\(\s*[\d-]+\s*,\s*["a-zA-Z0-9-]+\s*,\s*["a-zA-Z0-9-]+\s*\))/);
	$args =~ s/\s//g;
	$args =~ s/"//g;    # don't think quotes are ever necessary, but they're *allowed*
	# ... and parse it ...
	($perms,$owner,$group) = ($args =~ /\(([\d-]+),([a-zA-Z0-9-]+),([a-zA-Z0-9-]+)/);
	# ... and wipe it when we're done.
	$filesline =~ s/%attr\s*\(\s*[\d-]+\s*,\s*["a-zA-Z0-9-]+\s*,\s*["a-zA-Z0-9-]+\s*\)//;
      }

      # Conffiles.  Note that Debian and RH have similar, but not
      # *quite* identical ideas of what constitutes a conffile.  Nrgh.
      # Note that dpkg will always ask if you want to replace the file - noreplace
      # is more or less permanently enabled.
##fixme
# also need to handle missingok (file that doesn't exist, but should be removed on uninstall)
# hmm.  not sure if such is **POSSIBLE** with Debian...  maybe an addition to %post?
      if ($filesline =~ s/%config\b(?:\s*\(\s*noreplace\s*\)\s*)?//) {
        $pkgdata{$subname}{conffiles} = 1;  # Flag it for later
        $conf = 'y';
      }

      # %doc needs extra processing, because it can be a space-separated list, and may
      # include both full and partial pathnames.  The partial pathnames must be fiddled
      # into place in the %install script, because Debian doesn't really have the concept
      # of "documentation file" that rpm does.  (Debian "documentation files" are files
      # in /usr/share/doc/<packagename>.)
##fixme:  unhandled case: %doc %defattr.  Eeep.
# don't really know what to do with %defattr, generally.  :(
      if ($filesline =~ s/%doc\s+//) {

# this could probably go elsewhere.
	my $pkgname = $pkgdata{$subname}{name};
	$pkgname =~ tr/_/-/;

	# have to extract the partial pathnames that %doc installs automagically
	foreach (split /\s+/, $filesline) {
	  if (not m|^[\%/]|) {
	    $doclist{$subname} .= " $_";
	    my ($element) = (m|([^/\s]+/?)$|);
	    $filesline =~ s|$_|%{_docdir}/$pkgname/$element|;
	  }
	}
      } # $filesline =~ /%doc\b/

      $filesline =~ s/^\s*//;	# Just In Case.  For, uh, neatness.
      chomp $filesline;

# due to Debian's total lack of real permissions-processing in its actual package
# handling component (dpkg-deb), this can't really be done "properly".  We'll have
# to add chown/chmod commands to the postinst instead.  Feh.
      $pkgdata{$subname}{'post'} .= "%{__chown} -Rh $owner $filesline\n" if $owner ne '-';
      $pkgdata{$subname}{'post'} .= "%{__chgrp} -Rh $group $filesline\n" if $group ne '-';
      $pkgdata{$subname}{'post'} .= "if [ -d $filesline ]; then %{__chmod} $defattr{dirmode} $filesline; fi\n" if $defattr{dirmode} ne '-';
      $pkgdata{$subname}{'post'} .= "if [ -f $filesline ]; then %{__chmod} $perms $filesline; fi\n" if $perms ne '-';

##fixme
# need hackery to assure only one filespec per %config.  NB:  "*" is one filespec.  <g>
      push @{$pkgdata{$subname}{conflist}}, $filesline if $conf ne '-';

      # now that we've got the specials out of the way, we can add things to the appropriate list of files.
      # ... and finally everything else
      $filelist{$subname} .= " $filesline";

      next LINE;
    } # files

    if ($stage eq 'changelog') {
      # this is one of the few places we do NOT generally want to replace macros...
      $pkgdata{main}{changelog} .= $_;
      next LINE;
    }

    if ($stage eq 'preamble') {
      if (/^summary:\s*(.+)/i) {
        $pkgdata{main}{summary} = $1 unless defined $pkgdata{main}{summary};
      } elsif (/^name:\s*(.+)/i) {
        $pkgdata{main}{name} = $1 unless defined $pkgdata{main}{name};
      } elsif (/^epoch:\s*(.+)/i) {
        $pkgdata{main}{epoch} = $1 unless defined $pkgdata{main}{epoch};
      } elsif (/^version:\s*(.+)/i) {
        $pkgdata{main}{version} = $1 unless defined $pkgdata{main}{version};
      } elsif (/^release:\s*(.+)/i) {
        $pkgdata{main}{release} = expandmacros($1) unless defined $pkgdata{main}{release};
      } elsif (/^group:\s*(.+)/i) {
        $pkgdata{main}{group} = $1 unless defined $pkgdata{main}{group};
      } elsif (/^copyright:\s*(.+)/i) {
        $pkgdata{main}{copyright} = $1 unless defined $pkgdata{main}{copyright};
      } elsif (/^url:\s*(.+)/i) {
        $pkgdata{main}{url} = $1 unless defined $pkgdata{main}{url};
      } elsif (/^packager:\s*(.+)/i) {
        $pkgdata{main}{packager} = $1 unless defined $pkgdata{main}{packager};
      } elsif (/^vendor:\s*(.+)/i) {
        $specglobals{vendor} = $1 unless defined $specglobals{vendor};
      } elsif (/^buildroot:\s*(.+)/i) {
        $specglobals{buildroot} = $1 unless defined $specglobals{buildroot};
      } elsif (my ($srcnum, $src) = (/^source(\d*):\s*(.+)/i)) {
        $src =~ s/\s*$//;
        $srcnum = 0 unless $srcnum;
        $pkgdata{sources}{$srcnum} = basename($src);
        $pkgdata{main}{source} = $pkgdata{sources}{0} if 0 == $srcnum;
      } elsif (my ($patchnum, $patch) = (/^patch(\d*):\s*(.+)/i)) {
        $patch =~ s/\s*$//;
        $patchnum = '' unless defined($patchnum);
        $pkgdata{main}{$patchnum} = basename($patch);
      } elsif (/^buildarch(?:itecture)?:\s*(.+)/i) {
        $pkgdata{main}{arch} = $1;
        $pkgdata{main}{arch} =~ s/^noarch$/all/;
        $buildarch = $pkgdata{main}{arch};
      } elsif (/^buildrequires:\s*(.+)/i) {
        $buildreq .= ", $1";
      } elsif (/^requires:\s*(.+)/i) {
        $pkgdata{main}{requires} .= ", $1";
      } elsif (/^provides:\s*(.+)/i) {
        $pkgdata{main}{provides} .= ", $1";
      } elsif (/^conflicts:\s*(.+)/i) {
        $pkgdata{main}{conflicts} .= ", $1";
      } elsif (/^recommends:\s*(.+)/i) {
        $pkgdata{main}{recommends} .= ", $1";
	warn "Warning:  Debian-specific 'Recommends:' outside \%if wrapper\n" if 0 == @ifexpr;
# As of sometime between RHEL 6 and RHEL 7 or so, support was added for Recommends: and Enhances:,
# along with shiny new tag Supplements:.  We'll continue to warn about them for a while.
      } elsif (/^suggests:\s*(.+)/i) {
        $pkgdata{main}{suggests} .= ", $1";
	warn "Warning:  'Suggests:' outside \%if wrapper\n" if 0 == @ifexpr;
      } elsif (/^enhances:\s*(.+)/i) {
        $pkgdata{main}{enhances} .= ", $1";
	warn "Warning:  'Enhances:' outside \%if wrapper\n" if 0 == @ifexpr;
      } elsif (/^supplements:\s*(.+)/i) {
        $pkgdata{main}{enhances} .= ", $1";
        warn "Warning:  'Supplements:' is not natively supported by .deb packages.  Downgrading relationship to Enhances:.\n";
      } elsif (/^replaces:\s*(.+)/i) {
        $pkgdata{main}{replaces} .= ", $1";
	warn "Warning:  'Replaces:' outside \%if wrapper\n" if 0 == @ifexpr;
      } elsif (/^obsoletes:\s*(.+)/i) {
        $pkgdata{main}{replaces} .= ", $1";
      } elsif (/^autoreq(?:prov)?:\s*(.+)/i) {
	# we don't handle auto-provides (yet)
	$NoAutoReq = 1 if $1 =~ /(?:no|0)/i;
      }
      next LINE;
    } # preamble

  } # while <SPEC>

  # Expand macros as necessary.
  $specglobals{buildroot} = expandmacros($specglobals{buildroot});

  $scriptletbase = expandmacros($scriptletbase);

  close SPECFILE;
} # end parse_spec()


## prep()
# Writes and executes the %prep script (mostly) built while reading the spec file.
sub prep {
  # create script filename
  my $prepscriptfile = "$tmpdir/deb-tmp.prep.".int(rand(99998)+1);
  sysopen(PREPSCRIPT, $prepscriptfile, O_RDWR | O_CREAT | O_EXCL | O_NOFOLLOW)
	or die "Can't open/create prep script file $prepscriptfile: $!\n";
  print PREPSCRIPT $scriptletbase;
  print PREPSCRIPT expandmacros($prepscript);
  close PREPSCRIPT;

  # execute
  print "Calling \%prep script $prepscriptfile...\n";
  system("/bin/sh -e $prepscriptfile") == 0
	or die "Can't exec: $!\n";

  # and clean up
  unlink $prepscriptfile;
} # end prep()


## build()
# Writes and executes the %build script (mostly) built while reading the spec file.
sub build {
  # create script filename
  my $buildscriptfile = "$tmpdir/deb-tmp.build.".int(rand(99998)+1);
  sysopen(BUILDSCRIPT, $buildscriptfile, O_RDWR | O_CREAT | O_EXCL | O_NOFOLLOW)
	or die "Can't open/create build script file $buildscriptfile: $!\n";
  print BUILDSCRIPT $scriptletbase;
  print BUILDSCRIPT expandmacros($buildscript);
  close BUILDSCRIPT;

  # execute
  print "Calling \%build script $buildscriptfile...\n";
  system("/bin/sh -e $buildscriptfile") == 0
	or die "Can't exec: $!\n";

  # and clean up
  unlink $buildscriptfile;
} # end build()


## install()
# Writes and executes the %install script (mostly) built while reading the spec file.
sub install {

  # munge %doc entries into place
  # rpm handles this with a separate executed %doc script, we're not going to bother.
  foreach my $docpkg (keys %doclist) {
    my $pkgname = $pkgdata{$docpkg}{name};
    $pkgname =~ s/_/-/g;

    $installscript .= "DOCDIR=\$RPM_BUILD_ROOT\%{_docdir}/$pkgname\nexport DOCDIR\n";
    $installscript .= "%{__mkdir_p} \$DOCDIR\n";
    $doclist{$docpkg} =~ s/^\s*//;
    foreach (split(' ',$doclist{$docpkg})) {
      $installscript .= "%{__cp} -pr $_ \$DOCDIR/\n";
    }
  }

  # create script filename
  my $installscriptfile = "$tmpdir/deb-tmp.inst.".int(rand(99998)+1);
  sysopen(INSTSCRIPT, $installscriptfile, O_RDWR | O_CREAT | O_EXCL | O_NOFOLLOW)
	or die "Can't open/create install script file $installscriptfile: $!\n";
  print INSTSCRIPT $scriptletbase;
  print INSTSCRIPT expandmacros($installscript);
  close INSTSCRIPT;

  # execute
  print "Calling \%install script $installscriptfile...\n";
  system("/bin/sh -e $installscriptfile") == 0
	or die "Can't exec: $!\n";

  # and clean up
  unlink $installscriptfile;

  # final bit: compress manpages if present
  # done here cuz I don't grok shell well
  # should probably error-check all kinds of things.  <g>
  if (opendir MANROOT, "$specglobals{buildroot}/usr/share/man") {
    my @mansects = readdir MANROOT;
    closedir MANROOT;
    foreach my $mandir (@mansects) {
      next if $mandir !~ /^man/;
      opendir MANPAGES, "$specglobals{buildroot}/usr/share/man/$mandir";
      my @pagelist = readdir MANPAGES;
      closedir MANPAGES;			# Slightly safer to to this;  no accidental recursion.  O_o
      foreach my $manpage (@pagelist) {
        $manpage = "$specglobals{buildroot}/usr/share/man/$mandir/$manpage";
        if ( -f $manpage) {
	  if ($manpage =~ /^(.+)\.(?:Z|gz|bz2)\n?$/) {
	    my $newpage = $1;
	    `gunzip $manpage` if $manpage =~ /\.(?:Z|gz)$/;
	    `bunzip2 $manpage` if $manpage =~ /\.bz2$/;
	    $manpage = $newpage;
	  }
	  `gzip -f -9 -n $manpage`;
        } elsif ( -l $manpage) {
	  my $linkdest = readlink $manpage;
	  $linkdest =~ s/\.(?:Z|gz|bz2)//;
	  unlink $manpage;
	  $manpage =~ s/\.(?:Z|gz|bz2)//;
	  symlink "$linkdest.gz", "$manpage.gz" or print "DEBUG: wibble: symlinking manpage failed: $!\n";
        }
      }
    }
  } # if opendir MANROOT
} # end install()


## binpackage()
# Creates the binary .deb package from the installed tree in $specglobals{buildroot}.
# Writes and executes a shell script to do so.
# Creates miscellaneous files required by dpkg-deb to actually build the package file.
# Should handle simple subpackages
sub binpackage {

  foreach my $pkg (@pkglist) {

    $pkgdata{$pkg}{arch} = $pkgdata{main}{arch} unless $pkgdata{$pkg}{arch};  # Just In Case.

    # Make sure we have somewhere to write the .deb file
    if (not -e "$topdir/DEBS/$pkgdata{$pkg}{arch}") {
      mkdir "$topdir/DEBS/$pkgdata{$pkg}{arch}";
    }

    # Skip building a package that doesn't have any files or dependencies.  True
    # metapackages don't have any files, but they depend on a bunch of things.
    # Packages with neither have, essentially, no content.
    next if 
        (not $filelist{$pkg} or $filelist{$pkg} =~ /^\s*$/) &&
        (not $pkgdata{$pkg}{requires});
    $filelist{$pkg} = '' unless $filelist{$pkg};

    # Gotta do this first, otherwise we don't have a place to move files from %files
    mkdir "$specglobals{buildroot}/$pkg";

    # Eliminate any lingering % macros
    $filelist{$pkg} = expandmacros($filelist{$pkg});

    my @pkgfilelist = split ' ', $filelist{$pkg};
    foreach my $pkgfile (@pkgfilelist) {
      $pkgfile = expandmacros($pkgfile);

      # Feh.  Manpages don't **NEED** to be gzipped, but rpmbuild does, and so shall we.
      # ... and your little info page too!
      if ($pkgfile =~ m{/usr/share/(?:man/man|info)}) {
	# need to check to see if manpage is gzipped
	if (-e "$specglobals{buildroot}$pkgfile") {
	  # if we've just been pointed to a manpage section with "many" pages,
	  # we need to gzip them all.
	  # fortunately, we do NOT need to explicitly track each file for the
	  # purpose of stuffing them in the package...  the original %files
	  # entry will do just fine.
	  if ( -d "$specglobals{buildroot}$pkgfile") {
	    foreach my $globfile (glob("$specglobals{buildroot}$pkgfile/*")) {
	      qx { gzip $globfile } if $globfile !~ m|\.gz$|;
	    }
	  } else {
	    if ($pkgfile !~ m|\.gz$|) {
	      qx { gzip $specglobals{buildroot}$pkgfile };
	      $pkgfile .= ".gz";
	    }
	  }
	} else {
	  if ($pkgfile !~ m|\.gz$|) {
	    $pkgfile .= ".gz" unless $pkgfile =~ /\*$/;
	  } else {
	    $pkgfile =~ s/\.gz$//;
	    qx { gzip $specglobals{buildroot}$pkgfile };
	    $pkgfile .= ".gz";
	  }
	}
      }

      my ($fpath,$fname) = ($pkgfile =~ m|(.+?/?)?([^/]+/?)$|);	# We don't need $fname now, but we might.
      qx { $specglobals{__mkdir} -p $specglobals{buildroot}/$pkg$fpath } if $fpath;
      qx { $specglobals{__cp} -ar $specglobals{buildroot}$pkgfile $specglobals{buildroot}/$pkg$fpath };
    }

    # Get the "Depends" (Requires) a la RPM.  Ish.  We strip the leading
    # comma and space here (if needed) in case there were "Requires" specified
    # in the spec file - those would precede these.
    $pkgdata{$pkg}{requires} .= getreqs("$specglobals{buildroot}/$pkg") unless $NoAutoReq;

    # magic needed to properly version dependencies...
    # only provided deps will really be included
    $pkgdata{$pkg}{requires} =~ s/^, //;	# Still have to do this here.
    $pkgdata{$pkg}{requires} =~ s/\s//g;
    my @deps = split /,/, $pkgdata{$pkg}{requires};
    my $tmp = '';
    foreach my $dep (@deps) {
      # Hack up the perl(Class::SubClass) deps into something dpkg can understand.
      # May or may not be versioned.
      # We do this first so the version rewriter can do its magic next.
      if (my ($mod,$ver) = ($dep =~ /^perl\(([A-Za-z0-9\:\-]+)\)([><=]+.+)?/) ) {
	$mod =~ s/^perl\(//;
	$mod =~ s/\)$//;
	$mod =~ s/::/-/g;
	$mod =~ tr/A-Z/a-z/;
	$mod = "lib$mod-perl";
	$mod .= $ver if $ver;
	$dep = $mod;
      }
      if (my ($name,$rel,$value) = ($dep =~ /^([a-zA-Z0-9._-]+)([><=]+)([a-zA-Z0-9._-]+)$/)) {
        $tmp .= ", $name ($rel $value)";
      } else {
        $tmp .= ", $dep";
      }
    }
    ($pkgdata{$pkg}{requires} = $tmp) =~ s/^, //;

    # Do this here since we're doing {depends}...
    foreach my $label (('provides','conflicts',
                        # These are Debian-specific!
                        'recommends','suggests','enhances','replaces')) {
      if (defined($pkgdata{$pkg}{$label})) {
        $pkgdata{$pkg}{$label} =~ s/^, //;
        $pkgdata{$pkg}{$label} = expandmacros($pkgdata{$pkg}{$label});
      }
    }

    # Gotta do this next, otherwise the control file has nowhere to go.  >:(
    mkdir "$specglobals{buildroot}/$pkg/DEBIAN";

    # Hack the filename for the package into a Debian-tool-compatible format.  GRRRRRR!!!!!
    # Have I mentioned I hate Debian Policy?
    $pkgdata{$pkg}{name} =~ tr/_/-/;

    # create script filename
    my $debscriptfile = "$tmpdir/deb-tmp.pkg.".int(rand(99998)+1);
    sysopen(DEBSCRIPT, $debscriptfile, O_RDWR | O_CREAT | O_EXCL | O_NOFOLLOW)
	or die "Can't open/create package-creation script file $debscriptfile: $!\n";
    print DEBSCRIPT $scriptletbase;
    print DEBSCRIPT "fakeroot -- dpkg-deb -b $specglobals{buildroot}/$pkg $topdir/DEBS/$pkgdata{$pkg}{arch}/".
	"$pkgdata{$pkg}{name}_".
	(defined($pkgdata{main}{epoch}) ? "$pkgdata{main}{epoch}:" : '').
	"$pkgdata{$pkg}{version}-$pkgdata{main}{release}_$pkgdata{$pkg}{arch}.deb\n";
      # %$&$%@#@@#%@@@ Debian and their horrible ugly package names.  >:(
    close DEBSCRIPT;

    $pkgdata{$pkg}{summary} = expandmacros($pkgdata{$pkg}{summary});
    my $control = "Package: $pkgdata{$pkg}{name}\n".
	"Version: ".(defined($pkgdata{main}{epoch}) ? "$pkgdata{main}{epoch}:" : '').
	"$pkgdata{$pkg}{version}-$pkgdata{main}{release}\n".
	"Section: ".($pkgdata{$pkg}{group} ? $pkgdata{$pkg}{group} : defined $pkgdata{main}{group} ? $pkgdata{main}{group} : '')."\n".
	"Priority: optional\n".
	"Architecture: $pkgdata{$pkg}{arch}\n".
	"Maintainer: $pkgdata{main}{packager}\n".
	( $pkgdata{$pkg}{requires} ne '' ? "Depends: $pkgdata{$pkg}{requires}\n" : '' ).
	( defined($pkgdata{$pkg}{provides}) ? "Provides: $pkgdata{$pkg}{provides}\n" : '' ).
	( defined($pkgdata{$pkg}{conflicts}) ? "Conflicts: $pkgdata{$pkg}{conflicts}\n" : '' ).
	( defined($pkgdata{$pkg}{recommends}) ? "Recommends: $pkgdata{$pkg}{recommends}\n" : '' ).
	( defined($pkgdata{$pkg}{suggests}) ? "Suggests: $pkgdata{$pkg}{suggests}\n" : '' ).
	( defined($pkgdata{$pkg}{enhances}) ? "Enhances: $pkgdata{$pkg}{enhances}\n" : '' ).
	( defined($pkgdata{$pkg}{replaces}) ? "Replaces: $pkgdata{$pkg}{replaces}\n" : '' ).
	"Description: $pkgdata{$pkg}{summary}\n";
    $pkgdata{$pkg}{desc} = expandmacros($pkgdata{$pkg}{desc});
    # Munge things so that Debian tools don't choke on errant blank lines
    $pkgdata{$pkg}{desc} =~ s/\s+$//g;		# Trim trailing blanks
    $pkgdata{$pkg}{desc} =~ s/^ $/ ./mg;	# Replace lines consisting of " \n" with " .\n"
    $control .= "$pkgdata{$pkg}{desc}\n";

    open CONTROL, ">$specglobals{buildroot}/$pkg/DEBIAN/control";
    print CONTROL $control;
    close CONTROL;

    # Iff there are conffiles (as specified in the %files list(s), add'em
    # in so dpkg-deb can tag them.
    if ($pkgdata{$pkg}{conffiles}) {
      open CONFLIST, ">$specglobals{buildroot}/$pkg/DEBIAN/conffiles";
      foreach my $conffile (@{$pkgdata{$pkg}{conflist}}) {
	$conffile = expandmacros($conffile);
	my @tmp = glob "$specglobals{buildroot}/$pkg/$conffile";
	foreach (@tmp) {
	  s|$specglobals{buildroot}/$pkg/||g;	# nrgl.  gotta be a better way to do this...
	  s/\s+/\n/g;	# Not gonna support spaces in filenames.  Ewww.
	  print CONFLIST "$_\n";
	}
      }
      close CONFLIST;
    }

    # found the point of scripts on subpackages.
    foreach my $scr ('pre','post','preun','postun') {
      my $scrfile = $scr;
      if ($scrfile !~ s/un/rm/) { $scrfile .= 'inst'; }
      if ($pkgdata{$pkg}{$scr}) {
        open SCRIPT, ">$specglobals{buildroot}/$pkg/DEBIAN/$scrfile";
        print SCRIPT "#!/bin/sh\nset -e\n\n";
        print SCRIPT expandmacros($pkgdata{$pkg}{$scr});
        close SCRIPT;
        chmod 0755, "$specglobals{buildroot}/$pkg/DEBIAN/$scrfile";
      }
    }

    # execute
    print "Calling package creation script $debscriptfile for $pkgdata{$pkg}{name}...\n";
    system("/bin/sh -e $debscriptfile") == 0
	or die "Can't exec: $!\n";

    $finalmessages .= "Wrote binary package ".
	"$pkgdata{$pkg}{name}_".
	(defined($pkgdata{main}{epoch}) ? "$pkgdata{main}{epoch}:" : '').
	"$pkgdata{$pkg}{version}-$pkgdata{main}{release}_$pkgdata{$pkg}{arch}.deb".
	" in $topdir/DEBS/$pkgdata{$pkg}{arch}\n";
    # and clean up
    unlink $debscriptfile;

  } # subpackage loop

} # end binpackage()


## srcpackage()
# Builds a .src.deb source package.  Note that Debian's idea of
# a "source package" is seriously flawed IMO, because you can't
# easily copy it as-is.
# Not quite identical to RPM, but Good Enough (TM).
sub srcpackage {
  # In case we were called with -bs.
  $pkgdata{main}{name} =~ tr/_/-/;
  my $pkgsrcname = "$pkgdata{main}{name}-".
	(defined($pkgdata{main}{epoch}) ? "$pkgdata{main}{epoch}:" : '').
	"$pkgdata{main}{version}-$pkgdata{main}{release}.sdeb";

  my $paxcmd;

  # We'll definitely need this later, and *may* need it sooner.
  my $barespec = basename($specglobals{specfile});

  # Copy the specfile to the build tree, but only if it's not there already.
##buglet: need to deal with silly case where silly user has put the spec
# file in a subdir of %{_topdir}/SPECS.  Ewww.  Silly user!
  if (abs_path($specglobals{specfile}) !~ /^$topdir\/SPECS/) {
    $paxcmd .= "%{__cp} %{specfile} %{_specdir};\n"
  }

  # use pax -w [file] [file] ... -f outfile.sdeb
  $paxcmd .= "(cd %{_topdir}; %{__pax} -L -w ";

  # some packages may not have a "main" source.
  $paxcmd .= "SOURCES/$pkgdata{main}{source} " if $pkgdata{main}{source};

  # create file list:  Source[nn], Patch[nn]
  foreach my $specbit (keys %{$pkgdata{main}} ) {
    next if $specbit eq 'source';
    $paxcmd .= "SOURCES/$pkgdata{main}{$specbit} " if $specbit =~ /^patch/;
##buglet: need to deal with case where patches are listed as URLs?
#  or other extended pathnames?  Silly !@$%^&!%%!%!! user!
  }

  foreach my $source (keys %{$pkgdata{sources}}) {
    # Skip Source0, since it's also $pkgdata{main}{source}.  Could arguably
    # just remove that instead, but I think that might backfire.
    next if $source eq '0';
    $paxcmd .= "SOURCES/$pkgdata{sources}{$source} ";
  }

  # add the spec file and write to source package destination.
  $paxcmd .= "SPECS/$barespec -f %{_srcdebdir}/$pkgsrcname)";

  # In case of %-macros...
  $paxcmd = expandmacros($paxcmd);
  
  system("$paxcmd") == 0 and
  $finalmessages .= "Wrote source package $pkgsrcname in $topdir/SDEBS.\n";
} # end srcpackage()


## clean()
# Writes and executes the %clean script (mostly) built while reading the spec file.
sub clean {
  # create script filename
  my $cleanscriptfile = "$tmpdir/deb-tmp.clean.".int(rand(99998)+1);
  sysopen(CLEANSCRIPT, $cleanscriptfile, O_RDWR | O_CREAT | O_EXCL | O_NOFOLLOW)
	or die $!;
  print CLEANSCRIPT $scriptletbase;
  print CLEANSCRIPT expandmacros($cleanscript);
  close CLEANSCRIPT;

  # execute
  print "Calling \%clean script $cleanscriptfile...\n";
  system("/bin/sh -e $cleanscriptfile") == 0
	or die "Can't exec: $!\n";

  # and clean up
  unlink $cleanscriptfile;
} # end clean()


## checkbuildreq()
# Checks the build requirements (if any)
# Spits out a rude warning and returns a true-false error if any
# requirements are not met.
sub checkbuildreq {
  return 1 unless $buildreq; # No use doing extra work.

  # expand macros 
  $buildreq = expandmacros($buildreq);

  if ( not -e "/usr/bin/dpkg-query" ) {
    print "**WARNING**  dpkg-query not found.  Can't check build-deps.\n".
	"  Required for sucessful build:\n".$buildreq."\n".
	"  Continuing anyway.\n";
    return 1;
  }

  my $reqflag = 1;  # unset iff a buildreq is missing

  $buildreq =~ s/^, //;	# Strip the leading comma and space
  my @reqlist = split /,\s+/, $buildreq;

  my @missinglist;
  foreach my $req (@reqlist) {
    # from rpmbuild error message
    # Dependency tokens must begin with alpha-numeric, '_' or '/'
##fixme:  check for suitable whitespace around $rel
    my ($pkg,$rel,$ver);

    # We have two classes of requirements - versioned and unversioned.
    if ($req =~ /[><=]/) {
      # Pick up the details of versioned buildreqs
      ($pkg,$rel,$ver) = ($req =~ /([a-z0-9._-]+)\s+([><=]+)\s+([a-z0-9._-]+)/);
    } else {
      # And the unversioned ones.
      $pkg = $req;
      $rel = '>=';
      $ver = 0;
    }

## Apparently a package that has been installed, then uninstalled, has a "known" dpkg status of
## "unknown ok not-installed" vs a package that has never been installed which returns nothing.  O_o
## Virtual packages, of course, *also* show as "not installed" like this (WTF?)
## This causes real packages to be misdetected as installed "possible virtual packages" instead of "missing
## packages".  I don't think there's really a solution until/unless Debian's tools properly register virtual
## packages as installed.
    my @pkglist = qx { dpkg-query --showformat '\${status}\t\${version}\n' -W $pkg };
    if (not $pkglist[0]) {
      print " * Missing build-dependency $pkg!\n  $pkglist[0]";
      $reqflag = 0;
      push @missinglist, $pkg;
    } else {
# real package, installed
#kdeugau:~$ dpkg-query --showformat '${status}\t${version}\n' -W libc-client2007e-dev 2>&1
#install ok installed    8:2007f~dfsg-1
# virtual package, provided by ???
#kdeugau:~$ dpkg-query --showformat '${status}\t${version}\n' -W libc-client-dev 2>&1
#unknown ok not-installed
# real package or virtual package not installed or provided
#kdeugau:~$ dpkg-query --showformat '${status}\t${version}\n' -W libdb4.8-dbg 2>&1
#dpkg-query: no packages found matching libdb4.8-dbg

      my ($reqstat,undef,undef,$reqver) = split /\s+/, $pkglist[0];
      if ($reqstat =~ /^unknown/) {
	# this seems to be a virtual package.
	print " * Warning: $pkg is probably installed but seems to be a virtual package.\n";
      } elsif ($reqstat =~ /^install/) {
	my ($resp) = qx { dpkg --compare-versions $reqver '$rel' $ver && echo "ok" };
	if ($resp !~ /^ok/) {
	  $reqflag = 0;
	  print " * Buildreq $pkg is installed, but wrong version ($reqver):  Need $ver\n"
        }
      } else {
	# whatever state it's in, it's not completely installed, therefore it's missing.
	print " * Missing build-dependency $pkg!\n  $pkglist[0]";
	$reqflag = 0;
        push @missinglist, $pkg;
      } # end not installed/installed check
    }
  } # end req loop

  print "To install all missing dependencies, run 'apt-get install ".join(' ', @missinglist)."'.\n" unless $reqflag;

  return $reqflag;
} # end checkbuildreq()


## getreqs()
# Find out which libraries/packages are required for any
# executables and libs in a given file tree.
# (Debian doesn't have soname-level deps;  just package-level)
# Returns an empty string if the tree contains no binaries.
# Doesn't work well on shell scripts. but those *should* be
# fine anyway.  (Yeah, right...)
sub getreqs() {
  my ($pkgtree) = @_;

  print "Checking library requirements...\n";
  my @binlist = qx { find $pkgtree -type f -perm 755 };

  return '' unless @binlist;

  my @reqlist;
  foreach (@binlist) {
    push @reqlist, qx { LANG=C ldd $_ };
  }

  # Get the list of libs provided by this package.  Still doesn't
  # handle the case where the lib gets stuffed into a subpackage.  :/
  my @intprovlist = qx { find $pkgtree -type f -name "*.so*" };
  my $provlist = '';
  foreach (@intprovlist) {
    s/$pkgtree//;
    $provlist .= "$_";
  }

  my %reqs;
  my $reqlibs = '';
  my %reqliblist;

  foreach (@reqlist) {
    next if /^$pkgtree/;
    next if /not a dynamic executable/;
    next if m|/lib(?:64)?/ld-linux|;	# Hack! Hack!  PTHBTT!  (libc suxx0rz)
    next if /linux-gate.so/;		# Kernel hackery for teh W1n!!1!1eleventy-one!1  (Don't ask.  Feh.)
    next if /linux-vdso.so/;		# More kernel hackery.  Whee!

    # Whee!  more hackery to detect provided-here libs.  Some apparently return from ldd as "not found".
    my ($a,$b) = split / => /;
    $a =~ s/\s//g;
    if ($b =~ /not found/) {
      next if qx { find $specglobals{buildroot} -name "*$a" };
    }

    my ($req) = (m|=\>\s+([a-zA-Z0-9._/+-]+)|); # dig out the actual library (so)name.
	# And feh, we need the *path*, since I've discovered a new edge case where
	# the same libnnn.1.2.3 *file*name is found across *several* lib dirs.  >:(

    # Ignore libs provided by this package.  Note that we don't match
    # on word-boundary at the *end* of the lib we're looking for, as the
    # looked-for lib may not have the full soname version. (ie, it may
    # "just" point to one of the symlinks that get created somewhere.)
    next if $provlist =~ /\b$req/;

    $reqlibs .= " $req";
    $reqliblist{$req} = 1;
  }

  if (%reqliblist) {
    foreach my $rlib (keys %reqliblist) {
      my $libpkg = qx { dpkg -S $rlib };
      ($libpkg,undef) = split /:/, $libpkg;
      $reqs{$libpkg} = 1;
    }
  }

  my $deplist = '';
  foreach (keys %reqs) {
    $deplist .= ", $_";
  }

# For now, we're done.  We're not going to meddle with versions yet.
# Among other things, it's messier than handling "simple" yes/no "do
# we have this lib?" deps.  >:(

  return $deplist;
} # end getreqs()


## install_sdeb()
# Extracts .sdeb contents to %_topdir as appropriate
sub install_sdeb {
  my ($srcpkg) = @_;
  die "Can't install $srcpkg\n" unless $srcpkg =~ /\.sdeb$/;
  $srcpkg = abs_path($srcpkg);

  my $paxcmd = "(cd %{_topdir}; %{__pax} -r -f $srcpkg)";

  # In case of %-macros...
  $paxcmd = expandmacros($paxcmd);
  
  system("$paxcmd") == 0 and
  print "Extracted source package $srcpkg to $topdir.\n";
} # end install_sdeb()


## expandmacros()
# Expands all %{blah} macros in the passed string
# Split up a bit with some sections so we don't spend time trying to
# expand macros that are only used in a few specific places.
my $nest_level = 0;
sub expandmacros {
  my ($macrostring) = @_;

  return '' if $macrostring =~ /^\s*#/; # skip comments
  return $macrostring unless $macrostring =~ /%/; # nothing to substitute

  die "Runaway recursive macro expansion aborted.\n" if $nest_level++ > 8;

  # Replace global macros
  $macrostring =~ s/%configure/%{configure}/g;
  $macrostring =~ s/%make_install/%{make_install}/;
  $macrostring =~ s/%makeinstall/%{makeinstall}/;
  $macrostring =~ s|%optflags|%{optflags}|g;
  $macrostring =~ s|%{optflags}|$optflags{$pkgdata{main}{arch}}|g;

  # Package data
    $macrostring =~ s|%{source0?}|%{_sourcedir}/$pkgdata{main}{source}|gi;
    foreach my $source (keys %{$pkgdata{sources}}) {
      $macrostring =~ s|%{source$source}|%{_sourcedir}/$pkgdata{sources}{$source}|gi;
    }
    $macrostring =~ s|%{patch(\d+)}|%{_sourcedir}/$pkgdata{main}{$1}|gi;
    $macrostring =~ s/%{(summary|name|epoch|version|release|group|copyright|url|packager)}/$pkgdata{main}{$1}/gi;

  # Globals, and not-so-globals
    # special %define's.  Handle the general case where we eval anything.
    # Even more general:  %(...) is a spec-parse-time shell code wrapper.
    # Prime example:
    #%define perl_vendorlib %(eval "`perl -V:installvendorlib`"; echo $installvendorlib)
      # Oy vey this gets silly for the perl bits.  Executing a shell to
      # call Perl to get the vendorlib/sitelib/whatever "core" globals.
      # This can do more, but...  eww.
    $macrostring =~ s|%\((.+?)\)|my $res = qx{/bin/sh -c '$1'}; chomp $res; $res;|eg;
      # Yay!  ' characters apparently get properly exscapededed.

    # support '%{getenv:HOME}' alongside '%(echo $HOME)'.
    $macrostring =~ s/%{getenv:([A-Z_]+)}/$ENV{$1}/g;

    # curious form of 'basename'? – strip domain host (and port)
    while ($macrostring =~ /%{u2p:(%{.+?})}/) {
      my $url = $1;
      my $expand = expandmacros($1);
      $expand =~ s|\w+://[\w\-.:]+||;
      $macrostring =~ s/%{u2p:$url}/$expand/g;
    }

    # %{defined <flag>}, %{undefined <flag>}
    $macrostring =~ s/%{defined (.+?)}/defined $specglobals{$1} || 0/eg;
    $macrostring =~ s/%{undefined (.+?)}/not defined $specglobals{$1} || 0/eg;

    # unescape multi-line macros
    $macrostring =~ s/\\"/"/g;
    $macrostring =~ s/\\\\/\\/g;
    $macrostring =~ s/([^\s])\\+\n/$1\n/g;

    # support for **some** %if constructs.  Note that this breaks somewhat if
    # there's no value specified...  but so does rpm.

    my $tmpcount = 0;	# runaway shutdown.  Not really sure how else to avoid getting stuck.
    while ($macrostring =~ m/%{([?!]+)([a-z0-9_.-]+)(?:\:([A-Za-z0-9_.\/\-\\\s]+)?)?}/g) {       #Whew....
      my $qex = $1;
      my $macro = $2;
      my $value = '';
      if (defined($3)) {
        $value = $3;
      } else {
        $value = $specglobals{$macro} if $specglobals{$macro};
      }
      my $neg = '1' if $qex =~ /\!/;
      if ($specglobals{$macro}) {
	$value = '' if $neg;
      } else {
	$value = '' unless $neg;
      }
      $macrostring =~ s/%{[?!]+[a-z0-9_.-]+(?:\:([A-Za-z0-9_.\/\-\\\s]+)?)?}/$value/;

# not certain about this, but I don't want to run away.  It *can* happen if planned carefully.  :/
# %makeinstall has 13 occurrences.  D'Oh!
die "excessive recursive macro replacement;  dying.\n" if $tmpcount++ > 14;

    } # while()

# should probably stick a "no runaway" flag in here...  Just In Case...
    # %define's
# note to self: find out valid chars for %define name/label so we can parse them
    while (my ($key) = ($macrostring =~ /%{([a-z0-9_:-]+)}/i) ) {
      if (defined $specglobals{$key}) {
        $macrostring =~ s|%{$key}|expandmacros($specglobals{$key})|eg;
      } else {
        $macrostring = expandmacros($macrostring);
      }
    }

  $nest_level--;

  return $macrostring;
} # end expandmacros()


## unpackcmd()
# Prepare the necessary commands for uncompressing and extracting the content
# of the source drop according to the file extension.
sub unpackcmd {
   my ($sourcedrop,$quietunpack) = @_;
   my $cmdstring;

   if ($sourcedrop =~ /\.zip$/) {
      # .zip files are not really tarballs
      $cmdstring .= "%{__unzip}".( $quietunpack ? ' -qq ' : ' ' ).
         "'%{_sourcedir}/$sourcedrop'";
   } elsif ($sourcedrop =~ /\.tar$/) {
      # plain .tar files don't need to be uncompressed
      $cmdstring .= "%{__tar} -x".( $quietunpack ? '' : 'vv' )."f ".
         "'%{_sourcedir}/$sourcedrop'";
   } else {
      $cmdstring .= decompress("%{_sourcedir}/$sourcedrop").
         " | %{__tar} -x".( $quietunpack ? '' : 'vv' )."f -";
   }
   return $cmdstring .= qq(\nSTATUS=\$?\nif [ \$STATUS -ne 0 ]; then\n  exit \$STATUS\nfi\n);
} # end unpackcmd()


## decompress()
# Determine the suitable decompressor according to the file extension.
sub decompress {
   my ($filename) = @_;
   my $decompressor =
      ( $filename =~ /\.(?:tgz|(?:gz|Z))$/ ? "%{__gzip}"  :
        $filename =~ /\.bz2$/              ? "%{__bzip2}" :
        $filename =~ /\.xz$/               ? "%{__xz}"    :
      die("Can't handle unknown file type '$filename'.") );
   return "$decompressor -dc '$filename'";
} # end decompress()


__END__



=head1 NAME

debbuild - Build Debian-compatible .deb packages from RPM .spec files

=head1 SYNOPSIS

 debbuild {-ba|-bb|-bp|-bc|-bi|-bl|-bs} [build-options] file.spec

 debbuild {-ta|-tb|-tp|-tc|-ti|-tl|-ts} [build-options] file.{tgz|zip|tar.{gz|bz2|xz|Z}}
 debbuild {-ra|-rb|-rp|-rc|-ri|-rl|-rs} [build-options] file.{.src.rpm|sdeb}

 debbuild {--rebuild|--recompile} file.{src.rpm|sdeb}

 debbuild --showpkgs

 debbuild {--install|-i} foo.sdeb

=head1 DESCRIPTION

debbuild attempts to build Debian-friendly semi-native packages from RPM spec files, 
RPM-friendly tarballs, and RPM source packages (.src.rpm files).  It accepts I<most> of the 
options rpmbuild does, and should be able to interpret most spec files usefully.  Perl 
modules should be handled via CPAN+dh-make-perl instead as it's simpler than even tweaking
a .spec template.

As far as possible, the command-line options are identical to those from rpmbuild, although 
several rpmbuild options are not supported:

 --showrc
 --clean
 --nobuild
 --rmsource
 --rmspec
 --sign
 --target

Some of these could probably be trivially added.  Feel free to send me a patch.  ;)

Complex spec files will most likely not work well, if at all.  Rewrite them from scratch - 
you'll have to make heavy modifications anyway.

If you see something you don't like, mail me.  Send a patch if you feel inspired.  I don't 
promise I'll do anything other than say "Yup, that's broken" or "Got your message".

The source package container I invented for debbuild, the .sdeb file, can be "installed"
with debbuild -i exactly the same way as a .src.rpm can be installed with "rpm -i".  Both
will unpack the file and place the source(s) and .spec file in the appropriate places in
%_topdir/SOURCES and %_topdir/SPECS respectively.

=head1 ASSUMPTIONS

As with rpmbuild, debbuild makes some assumptions about your system.

=over 4

=item *

Either you have rights to do as you please under /usr/src/debian, or you have created a file 
~/.debmacros containing a suitable %_topdir definition.

Both rpmbuild and debbuild require the directories %_topdir/{BUILD,SOURCES,SPECS}.  However, 
where rpmbuild requires the %_topdir/{RPMS,SRPMS} directories, debbuild  
requires %_topdir/{DEBS,SDEBS} instead.  Create them in advance;  
some subdirectories are created automatically as needed, but most are not.

=item *

/var/tmp must allow script execution - rpmbuild and debbuild both rely on creating and 
executing shell scripts for much of their functionality.  By default, debbuild also creates 
install trees under /var/tmp - however this is (almost) entirely under the control of the 
package's .spec file.

=item *
  
If you wish to --rebuild a .src.rpm, your %_topdir for both debbuild and rpmbuild must either 
match, or be suitably symlinked one direction or another so that both programs are effectively 
working in the same tree.  (Or you could just manually wrestle files around your system.)

You could symlink ~/.rpmmacros to ~/.debmacros (or vice versa) and save yourself some hassle 
if you need to rebuild .src.rpm packages on a regular basis.  Currently debbuild only uses the 
%_topdir macro definition, although there are many more things that rpmbuild can use from 
~/.rpmmacros.

=back

=head1 ERRATA

debbuild deliberately does a few things differently from rpm.

=head2 BuildArch or BuildArchitecture

rpm takes the last BuildArch entry it finds in the .spec file, whatever it is, and runs with 
that for all packages.  Debian's repository system is fairly heavily designed around the 
assumption that a single source package may generate small binary (executable) packages 
for each arch, and large binary arch-all packages containing shared data.

debbuild allows this by using the architecture specified by (in order of preference):

=over 4

=item * Host architecture

=item * BuildArch specified in .spec file preamble

=item * "Last specified" BuildArch for packages with several subpackages

=item * BuildArch specified in the %package section for that subpackage

=back

=head2 Finding out what packages should be built (--showpkgs)

rpmbuild does not include any convenient method I know of to list the packages a spec file 
will produce.  Since I needed this ability for another tool, I added it.

It requires the .spec file for the package, and produces a list of full package filenames 
(without path data) that would be generated by one of --rebuild, -ta, -tb, -ba, or -bb.  
This includes the .sdeb source package.

=head1 AUTHOR

debbuild was written by Kris Deugau <kdeugau@deepnet.cx>.  A version that approximates 
current is available at http://www.deepnet.cx/debbuild/.

=head1 BUGS

Funky Things Happen if you forget a command-line option or two.  I've been too lazy to bother 
fixing this.

Many macro expansions are unsupported or incompletely supported.

The generated scriptlets don't quite match those from rpmbuild exactly.  There are extra 
environment variables and preprocessing that I haven't needed (yet).

Dcumentation, such as it is, will likely remain perpetually out of date.

%_topdir and the five "working" directories under %_topdir could arguably be created by 
debbuild.  However, rpmbuild doesn't create these directories either.

=head1 SEE ALSO

rpm(8), rpmbuild(8), and pretty much any document describing how to write a .spec file.

=cut
